#### Leetcode题库32. 最长有效括号

给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

思路：

​	题目有点难，因为有很多的情况需要考虑，始终通过不了测试，最终是求了网络上的答案。

​	首要问题是如何判断我正在遍历的字符对前面的有效字符串是否是的。如果是有效的，则可以继续判断，如果是无效的，则可以确定有效字符串的长度，并重新开始(可能有点懂，我也是半懂不懂的)

​	只有一种确定情况可以判断这个字符是无效的，就是当左括号的数量小于右括号的数量时，之前的有效字符串长度就不可能继续增加，需要重新开始。

​	可以设置一个变量存储有效字符串的起始位置

​	[所以网络上使用栈的思想解决这个问题](https://www.cnblogs.com/hlk09/p/9559952.html)。

​	当读取字符为'('时，将字符的位置信息压入栈中。

​	当读取字符为')'时，需要分以下几种情况：

​	1.当栈为空，即左括号数量小于右括号数量时，有效字符串起始位置则为当前位置 + 1。(当前有效字符串长度不存在继续增加的情况)

​	2.当栈不为空，则出栈，说明当前位置的'('字符有相应的‘)’匹配。判断有效字符长度

​		若出栈后，栈为空，说明从起始位置到当前位置的都是有效的字符。

​		若出站后，栈不为空，说明从栈顶位置 + 1当当前位置都是有效的字符串。

第一版：

```python
class Solution(object):
    def longestValidParentheses(self, s):
        """
        :type s: str
        :rtype: int
        """
        lis = []
        # start为
        start = 0
        res = 0
        for i in range(len(s)):
            # 当读取字符为'('时，将字符的位置信息压入栈中。
            if s[i] == '(':
                lis.append(i)
            else:
                # 当栈为空,则说明当前有效字符串长度不存在继续增加的情况
                # 有效字符串起始位置则为当前位置 + 1
                if len(lis) == 0:
                    start = i + 1
                
                else:
                    temp = lis.pop()
                    # 若出栈后，栈为空，说明从起始位置到当前位置的都是有效的字符。
                    if len(lis) == 0:
                        # 比较当前的长度和res的长度大小
                        res = max(res, i - start + 1)
                    # 若出站后，栈不为空，说明从栈顶位置 + 1当当前位置都是有效的字符串。
                    else:
                        res = max(res, i - lis[-1])
        return res
```

第二版：

​	参照网络上的大神，使用动态规划的方法求解，通过逆序的方法进行求解

​	dp[i]表示从i位置开头，一直到末尾的有效字符长度(注意选择从后往前推的原因是由于会出现右括号小于左括号的现象，从前往后的话这种现象比较难解释，所以使用由后往前的方法讨论)

[参考链接](https://www.cnblogs.com/hlk09/p/9559952.html)，改成Python版本。

```python
class Solution(object):
    def longestValidParentheses(self, s):
        """
        :type s: str
        :rtype: int
        """
        # 使用dp存储有效字符长度
        dp = []
        for i in range(len(s)):
            dp.append(0)
        res = 0
        for i in range(len(s) - 2, -1, -1):
            # 若开头 ！= ‘(’，直接可以判断它是无效字符
            if s[i] == '(':
                # 使用j表示跳过有效字符后的下一个字符的坐标
                j = i + dp[i + 1] + 1
                if j < len(s) and s[j] == ')':
                    dp[i] = dp[i + 1] + 2
                    # j + 1表示考虑j+1是否包含有效字符，若有可以往前连起来
                    if j + 1 < len(s):
                        dp[i] += dp[j + 1]
            res = max(res, dp[i])

        return res
```

