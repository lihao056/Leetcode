#### Leetcode周赛-1017. 负二进制转换

给出数字 `N`，返回由若干 `"0"` 和 `"1"`组成的字符串，该字符串为 `N` 的**负二进制（base -2）**表示。

除非字符串就是 `"0"`，否则返回的字符串中不能含有前导零。

**示例 1：**

```
输入：2
输出："110"
解释：(-2) ^ 2 + (-2) ^ 1 = 2
```

**示例 2：**

```
输入：3
输出："111"
解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3
```

**示例 3：**

```
输入：4
输出："100"
解释：(-2) ^ 2 = 4
```

**提示：**

```
1.0 <= N <= 10^9
```

​	想法：一开始没有头绪，因为1，-2,4，-8这种排列总觉得不能把把所有数都按照这个编码

​	后来发现确实可以编码的，然后开始找规律，首先先判断整数对应于这个编码的长度，

​	由于是按照-2作为底数进行正负数必定间隔两个位置正数位数为1,3,5,7...。负数为2,4,6,8..。

​	所以可以通过这种方式判断长度，基于长度之后可以进行位置的判断。

​	位置判断：

​		1.我们对每个位进行判断，首先，由于底数为-2的关系，会有置一的条件。

​		2.一开始的想法是整数N与当前位置的数M（如当前位置为(-2)^7）是否为相同符号，相同则置为1。后来发现这个想法是有问题的，问题在于当N与当前位置数M相减后的数值过小的话会有问题。	

​		3.当判断完同号之后，还需要有一个问题，就是需要判断在当前位置（如-2^7）的之前所有与当前位置数M的符号相同的数（-2^5,-2^3...）相加后小于当前数值。

​		4.对于N来说，需要对每个位置进行处理，判断当前位置置1后，将N与其进行相减，得出来的数进行下一个位置数的判断。

​	可能解释起来有点累，不知道有没有讲清楚。

下面是代码：

```
class Solution:
    def baseNeg2(self, N: int) -> str:
    '''
    :type N:int
    :rtype final
    '''
        if N == 0:
            return '0'
        sign = 1 if (N > 0) else  -1		#判断符号
        temp = 0
        if sign == 1:						#根据不同符号判断长度
            length = 0
            while temp < N:
                temp += (-2) ** length
                length += 2
        else:
            length = 1
            while temp > N:
                temp += (-2) ** length
                length += 2
        length -= 1

        final = ""		
        for i in range(length):					# 对每个位置进行判断
            if (N * (-2) ** (length -1 -i))> 0:		# 判断N是否和当前位置数同号，不同号可以直接置0
                temp = length -1 -i
                temp_val = 0
                while (temp > 0):				# 对小于当前位置的所有符号相同的数相加求和
                    temp -= 2
                    if temp < 0:				# 防止出现负数的情况，为0的时候是可以的
                        break
                    temp_val += (-2) ** temp

                if ((N > 0) & (N > temp_val)):			# 对正负数需要不同处理
                    final += '1'
                    N -= (-2) ** (length -1 -i)
                elif ((N < 0) & (N < temp_val)):
                    final += '1'
                    N -= (-2) ** (length - 1 - i)
                else:
                    final += '0'
            else:
                final += '0'
        return final
```



