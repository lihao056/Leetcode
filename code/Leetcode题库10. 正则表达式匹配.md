#### Leetcode题库10. 正则表达式匹配

给定一个字符串 (`s`) 和一个字符模式 (`p`)。实现支持 `'.'` 和 `'*'` 的正则表达式匹配。

```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
```

匹配应该覆盖**整个**字符串 (`s`) ，而不是部分字符串。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```

**示例 3:**

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```

**示例 4:**

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```

**示例 5:**

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

思路：

​	这道题目很难，如果是刚刷题目的新手可能没有头绪，因为需要完全匹配，所以完全没有下手的空间。

​	后来参照了网上的思路，才稍微会有使用迭代操作的想法，事实上网上的很多方法也是使用迭代法。

​	使用迭代法的原因是对字符串s及匹配模式p，需要每个每个进行匹配，如果我们对一些情况进行判断后（如s[0]=p[0]）还需要继续对之后的数组进行相同的判断，这种情况就可以使用迭代算法。

​	根据网络上的博文，总共有以下一些情况需要单独列出来：

1. 若len(p)=0，则s必须要为0，否则返回False

2. 若len(p)=1，则len(s)=1,且s[0] == p[0]或p[0] == '.'		#这里需要注意，需要先判断长度是否为1后才接着下面的判断

   上面是对应于len(p)<= 1的时候，下面是会出现迭代操作的情况

3. 若p[1] != '*'，则需要先判断len(s)!=0，否则直接可以输出False，接下来需要判断s[0]和p[0]的情况，如果这两个符合的话则说明，s[0]和p[0]是相匹配的，则迭代检测s[1:], p[1:]。

4. 若p[1]为‘*‘的情况时，需要考虑的包括，len(s) != 0，及s[0]和p[0]的情况。

   如果剔除p[0],p[1]也可以进行匹配，则返回True。如果不行，则对s字符串的字符进行剔除，因为这个字符可以匹配，则不需要考虑了，然后对此进行循环判断，直到p[0]p[1]无法匹配后才跳出循环，说明这种情况已经考虑完全。

5. 最后则将p[0]p[1]剔除进行下一步匹配(迭代)的过程，至此全部完成

程序如下

```
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
            len_p = len(p)
            len_s = len(s)

            if len_p == 0: return len_s == 0			# 对应情况1

            if len_p == 1:								# 对应情况2
                return len_s == 1 and (s[0] == p[0] or p[0] == '.')

            if p[1] != '*':								# 对应情况3
                if len_s == 0: return False
                return (len_s != 0) and ((s[0] == p[0]) | (p[0] == '.')) & self.isMatch(s[1:], p[1:])
			
            while (len(s) != 0) and (s[0] == p[0]) | (p[0] == '.'):	# 对应情况4
                if self.isMatch(s, p[2:]): return True
                s = s[1:]
            
            return self.isMatch(s,p[2:])	# 对应情况5  
```

